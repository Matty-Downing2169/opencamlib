#summary To-Do list for CAM algorithms.

If you're interested in CAM algorithms and would like to help with this project, here is a list of algorithms and ideas that need implementing!
Please join us on the discussion list to explore what we do and where you can help: http://groups.google.com/group/opencamlib

= 1D algorithms =
Think of these as drilling tool paths.
 * Travelling salesman problem (TSP) solver. The boost graph-library contains some heuristic solution to this problem.
  * Genetic algorithm based?
  * simulated annealing based?
 * modified TSP: asymmetric graph. This could be used as a general algorithm for optimizing 2D paths. You come into a 'city' at the beginning of a cut and exit the 'city' after the cut (at another point in space). Or maybe you could implement this cutting idea with two cities per cut. As you enter the first city there is a zero-cost edge in the graph which you must travel along.

= 2D algorithms =
 * Line segment offset (a subset of the existing 3D waterline code)
 * Line/Arc segment offset (an exact voronoi-approach is on possibility, an approximate fiber/weave approach is the other)
 * Arc-filter (find arcs with given tolerance from short line segments)
 * *done* Line-filter

== 2D pocket/clearing algorithms ==
once we have a pocket or contour (from the offset algorithm) we need to clear(rough) it.
 * zigzag (use a graph-based approach, see paper by Arkin)
 * spiral
 * successive offset (need voronoi-offset function for this)
 * adaptive (see separate page AdaptiveRoughing)

= 3D algorithms =
 * Drop-Cutter 
  ** *done* Cyl, Ball, Bull, Cone cutters work. 
  ** Composite cutters ?? 
 * Push-cutter/Waterline
  ** most cutters work (Cyl, Ball, Bull)
  ** work needed on ConeCutter
  ** work needed on CompositeCutter
 * Cutter Location surfaces
  ** 2D triangulating an arbitrary pocket
  ** adaptive refinement of triangulation
  ** slicing/traversing the mesh to generate toolpaths
  ** geodesics aka. constant step-over
  ** classification of areas into steep/shallow
  ** const-scallop (requires estimating curvature of surface?)

= Cutting simulation =
 * To get better performance, integrate with OpenGL and use VBO-technique for rendering. 
 * Add all the cutter types. 
 * Color triangles based on what cutter is used. 
 * display/log material removal rate (verify that an adaptive pocketing algorithm actually works)
 * fixtures and other no-go areas
 * integrate with a g-code parser (EMC2 ?)

= Multi-threading + Benchmarking =
We are now using OpenMP, but if someone is keen on MPI or OpenCL, then those are interesting directions too!

A set of standard benchmarking tests + timing mechanisms would be useful for measuring improvements in algorithm speed. Compare benchmarks to other libraries (PyCAM etc)

Tests. Unit tests and larger machining tests are needed. Run these periodically to track improvement and discover new/old bugs.